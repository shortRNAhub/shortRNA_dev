if (!is.null(gr$type) && any(gr$type == "exon")) gr <- gr$exon
mcols(gr) <- mcols(gr)[, c("tx_id", "tx_type", "symbol")]
}
return(gr)
})
return(extra.gr1)
}
#' Finalize Transcripts
#'
#' This function finalizes the transcript information, including processing miRNA transcripts.
#'
#' @param tx A GRanges object containing transcript information
#' @param clusterMiRNA Whether to cluster miRNA annotations
#'
#' @return A finalized GRanges object containing transcript information
finalize_transcripts <- function(tx, clusterMiRNA) {
colnames(mcols(tx))[colnames(mcols(tx)) == "tx_type"] <- "tx_biotype"
names(tx) <- NULL
tx2 <- tx[grep("miRNA", tx$tx_biotype, invert = TRUE)]
tx3 <- tx[grep("miRNA", tx$tx_biotype)]
tx4 <- process_mir_transcripts(tx3)
tx <- Reduce(c, list(tx2, tx3, tx4))
tx <- tx[, c("tx_id", "tx_biotype", "symbol")]
if (clusterMiRNA) tx <- miRNAcluster(tx)
return(tx)
}
#' Process miRNA Transcripts
#'
#' This function processes miRNA transcripts.
#'
#' @param tx3 A GRanges object containing miRNA transcript information
#'
#' @return A processed GRanges object containing miRNA transcript information
process_mir_transcripts <- function(tx3) {
tx4 <- tx3[startsWith(tx3$symbol, "Mir")]
tx3 <- tx3[!startsWith(tx3$symbol, "Mir")]
tx4$symbol1 <- paste(tx4$symbol, tx4$tx_id, sep = "_")
tx4$tx_id1 <- tx4$symbol
tx4$tx_id1 <- gsub("Mir", "miR-", tx4$tx_id1)
tx4$symbol <- tx4$symbol1
tx4$tx_id <- tx4$tx_id1
tx4 <- tx4[, c("tx_id", "tx_biotype", "symbol")]
return(tx4)
}
#' Save Features
#'
#' This function saves the processed features to a file.
#'
#' @param tx A GRanges object containing transcript information
#' @param output_dir The directory to save the features file
#'
#' @return The path to the saved features file
save_features <- function(tx, output_dir) {
anno.out <- file.path(output_dir, "features.rds")
saveRDS(tx, file = anno.out)
message("Features saved in \n", anno.out)
return(anno.out)
}
#' @param ensdb An 'EnsDb' object
#' @param extra.seqs Extra transcript sequences to include
#' @param output_dir The directory to save the processed genome file
#'
#' @return The path to the processed genome file
#'
#' @importFrom ensembldb getGenomeTwoBitFile
#' @importFrom Biostrings getSeq writeXStringSet
#' @importFrom rtracklayer import
#' @importFrom R.utils gzip
process_genome <- function(genome, ensdb, extra.seqs, output_dir) {
if (is.null(genome)) genome <- getSeq(getGenomeTwoBitFile(ensdb))
if (is.character(genome) && length(genome) != 1) {
stop("`genome` should be the path to a fasta(.gz) file, or a BSgenome/TwoBitFile object")
}
if (is(genome, "TwoBitFile") || (length(genome) == 1 && grepl(pattern = "\\.2bit", x = genome))) {
genome <- import(genome)
}
isCompressed <- !is.character(genome) || grepl("\\.gz$", genome)
genome.out <- paste0("customGenome.fasta", ifelse(isCompressed, ".gz", ""))
genome.out <- file.path(output_dir, genome.out)
save_genome(genome, extra.seqs, genome.out, isCompressed)
return(genome.out)
}
#'
#' This function saves the processed genome data to a file.
#'
#' @param genome A genome object
#' @param extra.seqs Extra transcript sequences to include
#' @param genome.out The output file path for the genome
#' @param isCompressed Whether the output should be compressed
#'
#' @importFrom Biostrings writeXStringSet
#' @importFrom R.utils gzip
save_genome <- function(genome, extra.seqs, genome.out, isCompressed) {
if (is.null(extra.seqs)) {
if (!is.character(genome)) {
writeXStringSet(genome, genome.out, compress = TRUE)
} else {
file.copy(genome, genome.out)
if (!isCompressed) gzip(genome.out)
}
} else {
if (!is.character(genome)) {
genome <- c(genome, extra.seqs)
writeXStringSet(genome, genome.out, compress = TRUE)
} else {
file.copy(genome, genome.out)
writeXStringSet(extra.seqs,
filepath = genome.out,
append = TRUE
)
if (!isCompressed) gzip(genome.out)
}
}
message(
"Genome including eventual extra chromosomes was saved in:\n",
genome.out
)
}
#' Build Index
#'
#' This function builds the genome index using Rsubread.
#'
#' @param genome The path to the genome file
#' @param output_dir The directory to save the index
#' @param ... Additional arguments passed to `Rsubread::buildindex`
#'
#' @importFrom Rsubread buildindex
build_index <- function(genome, output_dir, ...) {
message("Now building the index...")
buildindex(
basename = paste0(output_dir, "/customGenome"),
reference = genome,
...
)
}
#' Cluster miRNA Annotations
#'
#' This function clusters miRNA annotations.
#'
#' @param tx A GRanges object containing transcript information
#'
#' @return A GRanges object with clustered miRNA annotations
#'
#' @importFrom GenomicRanges reduce
miRNAcluster <- function(tx) {
miRNA <- tx[tx$tx_biotype %in% c("miRNA", "miRNA_precursor")]
other <- tx[!tx$tx_biotype %in% c("miRNA", "miRNA_precursor")]
miRNA_reduced <- reduce(miRNA, min.gapwidth = 0L)
mcols(miRNA_reduced) <- DataFrame(
tx_id = paste(miRNA_reduced$tx_id, collapse = ","),
tx_biotype = "miRNA_cluster",
symbol = paste(miRNA_reduced$symbol, collapse = ",")
)
tx <- c(other, miRNA_reduced)
return(tx)
}
mm10_annoprep2 <- prepareAnnotation2(
ensdb = db_mmu$ensdb,
output_dir = "./",
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR),
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa),
resolveSplicing = NULL,
rules = defaultAssignRules(),
tRNAEnsembleRemove = TRUE,
clusterMiRNA = TRUE
)
mm10_annoprep
mm10_annoprep2
mm10_annoprep2 <- prepareAnnotation2(
ensdb = db_mmu$ensdb,
output_dir = "./",
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR),
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa),
resolveSplicing = NULL,
rules = defaultAssignRules(),
tRNAEnsembleRemove = TRUE,
clusterMiRNA = TRUE
)
library(shortRNA)
mm10_annoprep2 <- prepareAnnotation2(
ensdb = db_mmu$ensdb,
output_dir = "./",
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR),
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa),
resolveSplicing = NULL,
rules = defaultAssignRules(),
tRNAEnsembleRemove = TRUE,
clusterMiRNA = TRUE
)
devtools::load_all(".")
devtools::load_all(".")
mm10_annoprep2 <- prepareAnnotation2(
ensdb = db_mmu$ensdb,
output_dir = "./",
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR),
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa),
resolveSplicing = NULL,
rules = defaultAssignRules(),
tRNAEnsembleRemove = TRUE,
clusterMiRNA = TRUE
)
ensdb = db_mmu$ensdb
output_dir = "./"
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR)
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
resolveSplicing = NULL
rules = defaultAssignRules()
tRNAEnsembleRemove = TRUE
clusterMiRNA = TRUE
if (!dir.exists(output_dir)) dir.create(output_dir)
tx <- process_transcripts(ensdb, resolveSplicing, rules, tRNAEnsembleRemove)
ensdb
db_mmu <- getDB(tRNA_includeMt = FALSE)
mm10_annoprep2 <- prepareAnnotation2(
ensdb = db_mmu$ensdb,
output_dir = "./",
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR),
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa),
resolveSplicing = NULL,
rules = defaultAssignRules(),
tRNAEnsembleRemove = TRUE,
clusterMiRNA = TRUE
)
db_mmu$ensdb
ensdb = db_mmu$ensdb
output_dir = "./"
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR)
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
resolveSplicing = NULL
rules = defaultAssignRules()
tRNAEnsembleRemove = TRUE
clusterMiRNA = TRUE
if (!dir.exists(output_dir)) dir.create(output_dir)
tx <- process_transcripts(ensdb, resolveSplicing, rules, tRNAEnsembleRemove)
tx <- process_extra_sequences(tx, extra.seqs)
tx <- process_extra_granges(tx, extra.gr)
tx <- finalize_transcripts(tx, clusterMiRNA)
anno.out <- save_features(tx, output_dir)
genome <- process_genome(genome, ensdb, extra.seqs, output_dir)
genome
output_dir
extra.seqs
ensdb
genome
genome = NULL
genome <- process_genome(genome, ensdb, extra.seqs, output_dir)
genome <- getSeq(getGenomeTwoBitFile(ensdb))
isCompressed <- !is.character(genome) || grepl("\\.gz$", genome)
genome.out <- paste0("customGenome.fasta", ifelse(isCompressed, ".gz", ""))
genome.out <- file.path(output_dir, genome.out)
genome
extra.seqs
genome.out
isCompressed
save_genome(genome, extra.seqs, genome.out, isCompressed)
save_genome(c(genome, extra.seqs), genome.out, isCompressed)
genome
extra.seqs
c(genome, extra.seqs)
DNAString(genome, extra.seqs)
DNAStringSet(genome, extra.seqs)
DNAStringSet(c(genome, extra.seqs))
xscat(genome, extra.seqs)
library(Biostrings)
xscat(genome, extra.seqs)
DNAStringSet(c(genome, extra.seqs))
c(genome, extra.seqs)
list(genome, extra.seqs)
list(genome, unlist(extra.seqs))
c(genome, unlist(extra.seqs))
genome
extra.seqs
save_genome(genome, extra.seqs, genome.out, isCompressed)
class(genome)
class(extra.seqs)
ist(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
DNAStringSet(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
DNAStringSetList(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
es <- DNAStringSetList(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
es$rRNA
c(genome, extra.seqs)
class(genome)
class(extra.gr)
class(extra.seqs)
extra.seqs
class(extra.seqs) <- "DNAStringSet"
class(extra.seqs)
extra.seqs
c(genone, extra.seqs)
c(genome, extra.seqs)
library(Biostrings)
# Convert extra.gr to a DNAStringSet if it's not already
extra_combined <- c(extra.gr$rRNA, extra.gr$tRNA)
extra_combined <- DNAStringSet(extra_combined)
# Combine genome and extra_combined
combined_genome <- c(genome, extra_combined)
combined_genome
genome
extra.seqs
combined_genome
names(extra.seqs)
names(combined_genome)
extra_combined <- c(extra.gr$rRNA, extra.gr$tRNA)
extra_combined <- DNAStringSet(extra_combined)
extra_combined
extra.gr$rRNA
list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
library(Biostrings)
# Convert extra.gr to a DNAStringSet if it's not already
extra_combined <- c(extra.gr$rRNA, extra.gr$tRNA)
extra_combined <- DNAStringSet(extra_combined)
# Combine genome and extra_combined
combined_genome <- c(genome, extra_combined)
combined_genome
extra.seqs
extra_combined <- c(extra.gr$piRNA, extra.gr$miRNA)
extra_combined
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
library(Biostrings)
# Convert extra.gr to a DNAStringSet if it's not already
extra_combined <- c(extra.seqs$rRNA, extra.seqs$tRNA)
extra_combined <- DNAStringSet(extra_combined)
# Combine genome and extra_combined
combined_genome <- c(genome, extra_combined)
combined_genome
extra.seqs
genome
c(genome, extra.seqs)
DNAStringSet(genome, extra.seqs)
c(genome, DNAStringSet(extra.seqs))
class(genome)
class(extra.seqs)
if (is.null(extra.seqs)) {
if (!is.character(genome)) {
writeXStringSet(genome, genome.out, compress = TRUE)
} else {
file.copy(genome, genome.out)
if (!isCompressed) gzip(genome.out)
}
} else {
if (!is.character(genome)) {
genome <- c(genome, extra.seqs)
writeXStringSet(genome, genome.out, compress = TRUE)
} else {
file.copy(genome, genome.out)
writeXStringSet(extra.seqs,
filepath = genome.out,
append = TRUE
)
if (!isCompressed) gzip(genome.out)
}
}
c(genome, extra.seqs)
class(extra.seqs$rRNA)
class(genome)
single_dna_list <- as.list(single_dna)
c(as.list(genome), extra.seqs)
DNAStringSet(c(as.list(genome), extra.seqs))
# If splicing is not to be resolved
if (is.null(resolveSplicing)) {
p <- rules$priorities
resolveSplicing <- names(p)[p >= 0]
}
# If splicing is to be resolved
if (!is.null(resolveSplicing)) {
gs <- genes(ensdb,
filter = ~ tx_biotype != resolveSplicing,
columns = c("tx_id", "gene_id", "gene_biotype", "symbol")
)
gs$tx_id <- gs$symbol
gs$tx_biotype <- gs$gene_biotype
gs$gene_id <- gs$gene_biotype <- NULL
gs <- unique(gs)
anofilter <- ~ tx_biotype == resolveSplicing
} else {
anofilter <- NULL
}
tx <- exonsBy(ensdb,
filter = anofilter,
columns = c("tx_id", "tx_biotype", "symbol")
)
tx <- unlist(tx)
if ("tRNA" %in% names(extra.seqs) & tRNAEnsembleRemove) {
tx <- tx[grep("tRNA", tx$tx_biotype, invert = T)]
}
tx$tx_biotype[tx$tx_biotype == "miRNA"] <- ifelse(
test = width(tx[tx$tx_biotype == "miRNA"]) > 25,
yes = "miRNA_precursor", no = "miRNA"
)
# If additional sequence files are provided
if (!is.null(extra.seqs)) {
stopifnot(is.list(extra.seqs) || is(extra.seqs, "DNAStringSet"))
# If additional sequence files are provided as a list
if (is.list(extra.seqs)) {
m <- bind_rows(
lapply(extra.seqs, FUN = function(x) {
data.frame(
row.names = names(x), tx_id = names(x),
seq = as.character(x)
)
}),
.id = "tx_biotype"
)
extra.seqs <- DNAStringSet(m$seq)
m$seq <- NULL
names(extra.seqs) <- row.names(m)
mcols(extra.seqs) <- m
}
m <- mcols(extra.seqs)
if (is.null(m$tx_id)) m$tx_id <- names(extra.seqs)
names(extra.seqs) <- paste0("pseudoChr_", names(extra.seqs))
stopifnot(all(c("tx_id", "tx_biotype") %in% colnames(mcols(extra.seqs))))
if (is.null(m$symbol)) m$symbol <- m$tx_id
gr <- GRanges(names(extra.seqs), IRanges(1L, width = nchar(extra.seqs)),
strand = "+", tx_id = m$tx_id, tx_biotype = m$tx_biotype,
symbol = m$symbol
)
}
if (!is.null(resolveSplicing)) tx <- c(tx, gs)
if (!is.null(extra.seqs)) tx <- c(tx, gr)
tx <- tx[, c("tx_id", "tx_biotype", "symbol")]
colnames(mcols(tx))[colnames(mcols(tx)) == "tx_biotype"] <- "tx_type"
if (length(extra.gr) > 0) {
extra.gr1 <- lapply(names(extra.gr), FUN = function(x) {
gr <- extra.gr[[x]]
seqlevelsStyle(gr) <- "ensembl"
if (is(gr, "GRangesList")) {
stopifnot(!is.null(names(gr)))
if (!("tx_type" %in% colnames(gr@unlistData))) {
gr@unlistData$tx_biotype <- x
}
if (!("symbol" %in% colnames(gr@unlistData))) {
gr@unlistData$symbol <- gr@unlistData$tx_id
}
gr@unlistData <- gr@unlistData[, c("tx_id", "tx_type", "symbol")]
} else {
stopifnot("tx_id" %in% colnames(mcols(gr)))
if (!("tx_type" %in% colnames(mcols(gr)))) mcols(gr)$tx_biotype <- x
if (!("symbol" %in% colnames(mcols(gr)))) mcols(gr)$symbol <- x
if (!is.null(gr$type) && any(gr$type == "exon")) gr <- gr$exon
mcols(gr) <- mcols(gr)[, c("tx_id", "tx_type", "symbol")]
# gr <- split(gr, gr$tx_id)
}
return(gr)
})
tx2 <- tx[!overlapsAny(tx, do.call(c, extra.gr1))]
tx <- c(tx2, do.call(c, extra.gr1))
anno.out <- file.path(output_dir, "features.rds")
}
colnames(mcols(tx))[colnames(mcols(tx)) == "tx_type"] <- "tx_biotype"
names(tx) <- NULL
tx2 <- tx[grep("miRNA", tx$tx_biotype, invert = TRUE)]
tx3 <- tx[grep("miRNA", tx$tx_biotype)]
tx4 <- tx3[startsWith(tx3$symbol, "Mir")]
tx3 <- tx3[!startsWith(tx3$symbol, "Mir")]
tx4$symbol1 <- paste(tx4$symbol, tx4$tx_id, sep = "_")
tx4$tx_id1 <- tx4$symbol
tx4$tx_id1 <- gsub("Mir", "miR-", tx4$tx_id1)
tx4$symbol <- tx4$symbol1
tx4$tx_id <- tx4$tx_id1
tx4 <- tx4[, c("tx_id", "tx_biotype", "symbol")]
tx <- Reduce(c, list(tx2, tx3, tx4))
tx <- tx[, c("tx_id", "tx_biotype", "symbol")]
if (clusterMiRNA) tx <- miRNAcluster(tx)
saveRDS(tx, file = anno.out)
message("Features saved in \n", anno.out)
# If genome is not provided
if (is.null(genome)) genome <- getSeq(getGenomeTwoBitFile(ensdb))
if (is.character(genome) && length(genome) != 1) {
stop(
"`genome` should be the path to a fasta(.gz) file, or a ",
"BSgenome/TwoBitFile object"
)
}
if (is(genome, "TwoBitFile") || (length(genome) == 1 && grepl(pattern = "\\.2bit", x = genome))) {
genome <- import(genome)
}
isCompressed <- !is.character(genome) || grepl("\\.gz$", genome)
genome.out <- paste0("customGenome.fasta", ifelse(isCompressed, ".gz", ""))
genome.out <- file.path(output_dir, genome.out)
extra.seqs
class(extra.seqs)
extra.gr
c(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
class(c(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa))
extra.seqs
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
if (!is.null(extra.seqs)) tx <- c(tx, gr)
tx
!is.null(extra.seqs)
stopifnot(is.list(extra.seqs) || is(extra.seqs, "DNAStringSet"))
stopifnot(is.list(extra.seqs) || is(extra.seqs, "DNAStringSet"))
extra.seqs
m <- bind_rows(
lapply(extra.seqs, FUN = function(x) {
data.frame(
row.names = names(x), tx_id = names(x),
seq = as.character(x)
)
}),
.id = "tx_biotype"
)
m
extra.seqs <- DNAStringSet(m$seq)
m$seq <- NULL
names(extra.seqs) <- row.names(m)
mcols(extra.seqs) <- m
extra.seqs
genome = NULL
genome <- process_genome(genome, ensdb, extra.seqs, output_dir)
